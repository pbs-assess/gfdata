---
title: "gfdata `get_all' Vignette"
author: "Philina English"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gfdata `get_all' Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  # cache = TRUE,
  cols.print = 9,
  rows.print = 9,
  eval = TRUE,
  autodep = TRUE,
  fig.path = "get-all-figs/",
  cache.path = "get-all-cache/"
)
```

```{r, echo=FALSE, eval = TRUE, cache=FALSE}
.error <- tryCatch(get_ssids(), error = function(e) "Error")
.eval <- !identical(class(.error), "character")
.eval <- TRUE
```


# Why use a `get_all_*()` function?

The `get_all_*()` functions have been designed to retrieve all fishery-independent data relevant to a particular species, or set of species. 
If `ssid = NULL` they will return all fishery-independent data in the database, including trap (sablefish), longline, jig, and historic trawl surveys.  
If a character string of major stat area codes is provided to the argument `major`, than all sets or samples from that area will be returned. 
If retrieving data for multiple species at once, this function will be a lot faster than the original `get_*()` functions because sql scripts are called once rather than repeatedly for each species. 

## Non-standard data 

The `get_all_*()` functions will return sets or samples both within and beyond the current
design-based standards and survey grids. 
This includes sets and samples from grid cells that fall within Rockfish Conservation areas (RCAs), and data that differ at the skate level.

By contrast, the original `get_*()` survey functions focus on retrieving sets and samples that conform to current design-based standards and survey grids. 
This means that they do not retrieve sets and samples from cells that fall within Rockfish Conservation Areas, or that have otherwise been excluded from the latest version of the survey grid. 
<!-- Their default settings also exclude tows that are shorter than the standard length.  -->

Further, the original functions were not built to retrieve data that differed at the skate level (like gear comparison studies), which this function will return only when gear variables (currently checking for differences in hook code and size) differ between skates.


## Duplication of fishing events and specimens

The `get_all_*()` functions attempt to avoid duplication of fishing events and specimens.

One risk in using the original `get_*()` functions is that some fishing events and specimen ids may be duplicated in the resulting data set. 
This occurs because some vessel trips conduct sampling for multiple survey series, and unless joining is based on grouping codes (which aren't used consistently for some surveys ) the only way to connect a fishing event to a survey series id (SSID) is through the vessel trip. 
This can result in events and specimens getting assigned to both surveys that were conducted on the same trip. 
The most common instances of this have custom corrections coded into an internal function `correct_ssids()` that is applied automatically by the `get_all_*()` functions. 
Other ways duplication occurs can be due to missing covariates (e.g., both event level and survey defaults are missing for `doorspread_m` on a couple sets for some trawl series), or when multiple vials of DNA were collected and `return_dna_info = TRUE`. 


# Examples

If you don't already have the package installed, see the general gfdata vignette for instructions.
Here we will load gfdata along with the package dplyr.

```{r, cache=FALSE, warning = FALSE, message = FALSE}
library(gfdata)
library(dplyr)
```

The available arguments are described in the help documentation:

```{r, eval = FALSE}
?get_all_survey_sets()
?get_all_survey_samples()
```


## What species-specific data are available across all surveys? 

One common use-case for the `get_all_*()` functions is to determine all set or specimen
data available for a specific species across all survey data in the database.

As an example, we use `get_all_survey_sets()` to return all survey set data for Bluntnose Sixgill Sharks (*Hexanchus griseus*). For now, we will leave the default settings that pull all surveys and all areas. 
Some records in the database are from United States waters. If desired, returned data can be filtered to retain only Canadian records after all records are returned.

To allow direct comparison with the original `get_*()` functions, we will change one default argument by setting `remove_false_zeros = FALSE`. This will ensure that events returned by both functions will match. By default, `get_all_survey_sets()` removes false zeros.

Several warnings alert the user that [edit needed: what warnings are expected in common use?]

```{r, eval=TRUE, warning=TRUE}
d0 <- get_all_survey_sets("Bluntnose Sixgill Shark", 
                          remove_false_zeros = FALSE)
```

The `get_all_survey_sets()` function will return all sets for any survey that encountered the species. On survey trips [edit needed: survey trips, or survey series?] where some sets did capture the species, all sets are returned including sets that did not capture the species.

So, to make sets that did capture the species visible to `glimpse()`, We will sort by descending `catch_count` and `catch_weight`. 

```{r, eval=TRUE, warning=TRUE}
d0 <- d0 |> arrange(-catch_count, -catch_weight)
head(d0)
```

Notice that `catch_weight` sometimes contains zeros when `catch_count` is at least 1. This may be because some specimens may be too large for the scale and null values are assumed by our SQL calls to be zeros. To avoid this, use the argument `remove_false_zeros = TRUE`. [edit needed: consider setting to TRUE from the beginning to simplifiy the flow. I was confused why set to false without comparing to original `get_*()` function]

```{r, eval=TRUE, warning=TRUE}
d <- get_all_survey_sets("Bluntnose Sixgill Shark", 
                         remove_false_zeros = TRUE #> default
                         )
d <- d |> arrange(-catch_count, -catch_weight)
head(d)
```

So, which surveys encountered the most of this species? Some surveys only count individuals and others only weight the total catch, so we will summarize both count and weight variables.

```{r, message=FALSE}
d |> group_by(survey_series_id, survey_series_desc) |> 
  summarise(individuals = sum(catch_count, na.rm = TRUE),
            weight = sum(catch_weight),
            events = length(unique(fishing_event_id)),
            rows = n()) |>
  arrange(-individuals, -weight)
```

We can also tally the number of unique fishing events versus the number of rows of data returned. 
Data from surveys with more rows than events has been returned at the skate level. 
This will happen any time one of the surveys being returned has skates that differ in the gear (currently just working off differences in hook type) used within the same fishing event. 

This was the case for SSID 48, but this also results in all other surveys with skate level records returning data at this level too. 
If one preferred the other surveys with skate level data, which does not have hook differences between skates, to be summarized at the event level, thay could be called separately using the argument `ssid = c(14, 35)`.  

The vast majority of records for Bluntnose Sixgill Shark  come from the IPHC, followed by the Dogfish and Hard Bottom Longline surveys, both conducted in the Strait of Georgia (aka. Inside South). Because only the IPHC covers a wider area, we can explore the spatial distribution of catches within that survey only, and confirm that they are most frequently caught in the Strait of Georgia, major stat area "01". 

```{r, message=FALSE}
d |> filter(survey_series_id == 14) |> 
  group_by(major_stat_area_code) |> 
  summarise(individuals = sum(catch_count, na.rm = TRUE),
            weight = sum(catch_weight),
            events = length(unique(fishing_event_id))) |>
  arrange(-individuals, -weight)
```


## What survey samples are available for a species within a specific area?

As an example, we might want to determine what survey sample data exists for Pacific Spiny Dogfish in the Strait of Georgia. 
The area argument is `major` and accepts character vectors of major stat area codes. 
A table of options can be retrieved with `get_major_area()`. 

```{r, eval=.eval}
d2 <- get_all_survey_samples("north pacific spiny dogfish", major = c("01"))
```

```{r, eval=.eval, message=FALSE}
d2 |> group_by(survey_series_id, survey_series_desc) |> 
  summarise(specimens = length(unique(specimen_id)),
            lengths = sum(!is.na(length)),
            weights = sum(!is.na(weight)),
            age_structures = sum(age_specimen_collected)
            ) |>
  arrange(-specimens)
```

This should return all fishery-independent specimen records.
If you want to focus on specimens that come from design-based survey sets you can add arguments that filter for unsorted random samples that come from events that have grouping codes that match those expected for the current survey design. 
This can also be achieved by filtering for specimens where `!is.na(grouping_code)` and checking that the `sample_type_comment` and `sample_source_desc` notes are consistent with the specimens being from random samples.
Note: Some surveys do not use grouping codes, and therefore won't be returned when the `grouping_only` option is used. 
In this case, all of SSID 76 and 48 are missing. 

```{r, eval=.eval, message=FALSE}
d3 <- get_all_survey_samples("north pacific spiny dogfish", major = c("01"), 
                             unsorted_only = TRUE,
                             random_only = TRUE,
                             grouping_only = TRUE)

d3 |> group_by(survey_series_id, survey_series_desc) |> 
  summarise(specimens = length(unique(specimen_id)),
            lengths = sum(!is.na(length)),
            weights = sum(!is.na(weight)),
            age_structures = sum(age_specimen_collected)) |>
  arrange(-specimens)
```

Another common use-case returns additional fishing event information. These data can be used as covariates for model-based analyses. To return additional event information, use the argument `include_event_info = TRUE`.
For example, when this is applied to the various longline surveys in the Strait of Georgia, one can test the effects of variables like depth, date, hook type and size on the sex and sizes of fish caught.

```{r, eval=.eval, message=FALSE}
d4 <- get_all_survey_samples("north pacific spiny dogfish", major = c("01"), ssid = c(39, 40, 48, 76),
                             include_event_info = TRUE)
```

```{r, eval=.eval, message=FALSE}
d4 |> group_by(survey_series_id, activity_desc, hook_desc, hooksize_desc) |> 
  summarise(specimens = length(unique(specimen_id)),
            lengths = sum(!is.na(length)),
            years = paste(min(year), "-", max(year))) |>
  arrange(-specimens)
```
These are the variables returned by default: 

```{r, eval=.eval, message=FALSE}
glimpse(d2)
```
And these additional variables were returned for longline surveys when `include_event_info = TRUE`:

```{r, eval=.eval, message=FALSE}
glimpse(d4[, !names(d4) %in% names(d2)]) 
```

The collection of variables that are returned can change depending on the records that are retrieved. For example, variables that are specific to longline surveys are omitted when only trawl survey sets are returned.

## Surveys with overlapping stratifications

Some fishing events are assigned to multiple surveys, which may or may not be fully or partially overlapping, and are defined by the same activity code in the database. To get all sets with matching activity codes one can use `include_activity_matches = TRUE`. It will return all events that share the same `activity_code` as any SSIDs requested. This works when retrieving either sets or samples. 

```{r, eval=.eval, message=FALSE}
d5 <- get_all_survey_sets("north pacific spiny dogfish", ssid = c(7),
                             include_activity_matches = TRUE,
                             remove_duplicates = TRUE #> default
                             )

d5 |> group_by(survey_series_id, survey_abbrev, activity_desc) |> 
  summarise(events = length(unique(fishing_event_id)),
            years = paste(min(year), "-", max(year))) |>
  arrange(-events)
```

You will get a warning that some fishing events are duplicated even though `remove_duplicates = TRUE`. We can look at one of the duplicated events and see that it lacks location information, which means that it couldn't be accurately assigned to either region of shrimp survey, so it has been returned as potentially belonging to both. 

```{r, eval=.eval, message=FALSE}
dd <- d5[duplicated(d5$fishing_event_id),]
glimpse(dd)
```

[edit needed: replace "this" with what it is, e.g. "Duplication of events always..."?] This always occurs by default for the sablefish surveys (ssid = any of 35, 41, 42, 43), because SSIDs for that survey are confused by sharing trip ids. In order to separate the types of sablefish surveys one needs to split data from this survey by the `reason_desc` variable. 


